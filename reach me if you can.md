# 一、综述

许多安卓app会调用c/c++库文件，而没有实时更新的第三方组件会给安卓app带来许多安全漏洞。为了检测具体漏洞在程序执行时是否可达（**function reachability**），本文提出了DROIDREACH模型作为一种漏洞检测工具，该模型混合使用启发式算法和符号执行，从而构建更加准确的程序间控制流图（**ICFGs**）。解决了当前SOTA算法的一些缺陷。

DROIDREACH模型静态分析安卓app从而评价原生功能的可访问性，这对于评估安全性十分重要，因为脆弱但并不可达的功能不会立刻引起威胁。DROIDREACH模型相较于其他模型能够构建更加准确的ICFG图，对于安全性分析十分重要。

+++

# 二、主要工作

## 1、现有工作

静态方法：符号分析——在大规模复杂APP上的漏洞可达性分析结果不完全也不准确

动态方法：可以精确分析单一执行路径但是会导致路径爆炸问题（**path explosion**）

因此，需要找到精度和执行时间的一种平衡。

## 2、主要贡献

（1）分析现有技术限制：从Java native method到JNI Method的正确映射；

​                                             处理嵌套本地库（nested native libraries）

​                                             准确构建程序间控制流图（**ICFGs**）

（2）混合使用启发式算法和多种ICFGs构建算法解决上述技术限制，从而准确有效的重建达到潜在漏洞本地调用的可能路径。

（3）用500个流行app测试模型效果，发现DROIDREACH模型比SOTA模型效果更好。

（4）用两个具体的案例证明DROIDREACH模型可以用于漏洞可达性分析。

**DroidReach 找不到能够重现特定路径的输入，但可以提供有关是否存在到特定目标点的路径的见解。**

## 3、基本知识

Android Native Development Kit(NDK)：允许安卓使用本地代码的工具集

JNI：定义函数如何获得参数并提供返回值，本地库用System.loadLibrary 加载

Input Generation输入生成：导致具体功能执行的用户输入

> java方法的加载是将字节码加载到java 虚拟空间中，这个被加载的字节码的入口维持一个该类的所有方法的列表，在这个list上，记载了此种方法的代码存储地，参数和方法的描述符，当调用某一个方法的时候，java可以通过查找这个List，得到代码存储地址，从而进行运行。
>         如果一个方法描述符内有native字样，他不会在这个list中存储地址，而是存储一个指针，当程序调用相关的本地方法会通过指针找到相应的dll文件，加载dll文件到虚拟机中，如果没有找到dll文件，则会爆出无dll文件的系统错误。dll文件通过系统loadLibrary()或者load()方法加载,这两种方法的区别是loadLibrary()加载的时候会先找寻dependence.dll， 而load加载的时候需要先手工将dependence.dll 文件放入 java.library.path 的路径中。
>
> Native 方法的运行步骤
> 在Java 中声明Native() 方法并编译。
> 在javah中产生一个.h文件
> 基于dll文件，使用.cpp文件实现native的导出方法
> 编译 cpp文件使得器生成动态链接库文件
> 在Java中用System.loadLibrary（）方法加载动态链接库文件，程序便可调用此native文件。

+++

# 三、DROIDREACH

## 1、目标

ps进入节点entry point

pt想要在执行中到达的特定节点

目标：给出java层代码集和本地层代码集，对于一个pt，至少找一条从ps开始能够到达pt的路径。本文主要关注本地层中与漏洞相关的代码节点。

## 2、技术限制

从Java native method到JNI Method的正确映射：运行时java native method可以看成是跳转到JNI Method，是本地层native layer的入口

处理嵌套本地库（nested native libraries）：JNI是共享库的一部分，共享库可能从别的库中继续调用形成嵌套本地库。

可扩展性和准确性的平衡

## 3、结构（重要）

阶段一：静态分析java层：构建java代码的ICFG，并识别java native method

阶段二：分析Java层和本地层之间的交互

阶段三：静态分析本地层：构建本地库的ICFG，混合不同方法达到准确性和可扩展性的平衡

阶段四：可达性分析：将java层和本地层的ICFG混合，识别目标路径

### （1）静态分析java层（1）

识别数据源：通过分析不同安卓组件的类方法

对每个source，构建ICFG图

**source是污点数据的源，一般是有些函数的返回值，sink是特定的程序点，例如某些敏感函数**

识别java native method，此时java native method 还未实向JNI的映射

实现：Androguard或FlowDroid

### （2）分析Java层和本地层之间的交互

静态映射：JNI Method的名字符合特定规则，允许动态链接器唯一识别与之相连的Java Native Method

动态映射：JNI_OnLoad函数运用JNI primitive RegisterNatives实现动态映射，该方法将一个指向JNINativeMethod的指针作为自己的一个参数。JNINativeMethod结构包括java native method的名字，参数和返回值的类型以及可调用地址。

对于动态映射的检测，从前使用符号执行，但这样一到达给定深度探索就会停止，可能导致识别失败或者开销过大。

对于动态映射的检测，现在使用一个可扩展的启发式方法，假设开发者在编译时静态定义JNINativeMethod，将其方法全局数据部分，因此DROIDREACH模型可以扫描库的数据部分，查找符合name sign fnPtr模式的数组。如果启发式算法没有识别到包含JNI_OnLoad的映射或者识别到的映射在（name，sign）对上有冲突，那么重新进行符号执行。（不同类都叫name的jave native method对应相同的sign时会引起模糊）

### （3）静态分析本地层

把每个JNI Method作为一个切入点构建ICFG。为了解决嵌套本地库的问题，如果一个库的某个功能调用了另一库的内容，就递归地构建ICFG；为了达到准确性和可扩展性的平衡，混合使用多种方法

第一步：构建ICFG。对每个JNI Method，构建CFG和CG，使用Ghidra reversing framework（软件逆向工程（SRE）框架）

第二步：构建库依赖图，节点表示库，边表示不同库之间的调用，每条边上有（caller，callee）对来记录不同的调用

第三步：细化ICFG。运用库依赖图，为每个JNI Method构建的ICFG添加嵌套库的代码点，重复前两步

第四步：细化ICFG，符号探索。经过以上三步，仍然有一些边是缺失的，例如使用调用方定义的目标执行间接调用（ in the presence of a callee that performs an indirect call using a target defined by its caller）

<u>为了解决这个问题，对每个JNI Method，利用CFGEmulated of angr去执行一次符号探索。（ (state of) the art of war: Offensive techniques in binary analysis）</u>

> 控制流图有一个根本性困难：间接跳转。间接跳转发生在控制流的目标是一个值，一个寄存器或是一个内存地址。而直接跳转的目标通常是指令本身，因此可以简单的识别出来。
>
> 间接跳转：
> **计算跳转**：计算跳转的目标是由应用程序通过执行代码指定的计算来确定的。
>
> **上下文相关跳转**：一个间接跳转可能取决于应用程序的上下文。常见的例子就是在标准C库中的qsort()函数，这个函数使用了一个回调函数来比较传入的值。
>
> **对象跳转**：上下文的一个特例是对象。在面向对象的语言中，对象多态性需要使用虚函数，这些函数通常作为函数指针的虚表来实现，在运行时查询函数指针来确定跳转目标。

为了解决维度爆炸问题，当调用栈内包含五层嵌套调用后停止分析，重复第一二步，GHIDRA更可扩展，但不准确，CFG更准确但是不那么可扩展。

### （4）可达性分析

定义目的地sink：给出漏洞报告，目的地就是当执行重现bug时距离漏洞最近的代码点或代码集。为了识别开源项目中调用的库和相应版本，使用有效的二元相似性技术***<u>（Too quiet in the library: An empir- ¨ ical study of security updates in android apps’ native code.）</u>***

> 创建了一个专门用于分析APP中使用的第三方库的库名、版本信息的工具LibRARIAN。LibRARIAN(LibRAry veRsion IdentificAtioN)工具
> 这个工具实现的功能是给定一个二进制文件，它能表示出文件属于的库和对应的库版本。
> 工具本质上是一款二进制文件比较工具，利用一些特性和已知的第三方库信息进行对比得出判断结论。
>
> 提取特征可以分为5个元数据和1个数据项，分别为导入/导出全局变量、导入/导出函数、库依赖、文件中的特征字符串。

合并ICFG：根据JNI映射将java层的ICFG和native 层的ICFG合并

寻找从源头到目的地的路径：默认寻找最短路径，但是可以请求寻找其他路径

+++

# 四、实验

## 1、评价基准

定义了一个新的基准套件，包含十三个app，从不同角度体现了挑战中的不同方面。其中本模型成功检测了12个app的ICFG,Argus-SAF成功检测了8个模型的ICFG，失败的那个app中存在深层间接调用，这说明了本模型只能弥补而不能解决静态分析的可扩展性问题。

## 2、现实数据

细粒度分析fine-grained evaluation：分析假阳性和假阴性。

假阴性：该在不在——从数据集中选取15个app在Android模拟器上手动操作模拟用户在短期内可能进行的操作，记录所有执行到的本地功能入口native function entry points看看在不在已经建立的ICFG图内。检测结果本模型远远优于另外两个模型。

增加调用深度阈值和增加分析时间都可以在一定程度上提升模型性能，但是并不是所有情况下增加时间都能达到更好的效果。

假阳性：不该在在——由于不好检测，因此只能验证一个子集内的数据。对比分析本模型得到的ICFG图和另外两种方法得到的ICFG图，挑选出只在本模型中出现的功能入口function entry point，并根据S1 flowdroid的报告分析如何刺激他们的JNI Method。在调试器下执行每个app记录究竟哪个功能入口被执行了。但即使没有检测到被执行也不能立刻被认为是假阳性因为很多特定的使用模式难以被重现，对这些app，再运用IDA PRO分析他们的代码自己进行人工静态验证。

粗粒度分析：

即使一个app内包含了一些代码，但这些代码并不一定全部被执行

S2阶段评价：静态定义的映射可以被两种方法（本方法和ARGUS-SAF）很好的解决，而动态定义的映射本方法的效果更好，有了符号探索的帮助，本方法的效果更好，但是仍然有一些映射因为超时原因检测失败。

S3阶段评价：主要和ARGUS-SAF进行对比，DROIDREACH模型运行更慢，但是效果更好。

## 3、案例学习

用于评价漏洞的影响

### （1）reachable function

验证了DROIDREACH用于识别不包含直接跳转路径的能力

### （2）unreachable function

对于DROIDREACH识别出的不存在路径的情况，用中断svc 11指令修补本机库函数从而查看函数是否被调用，最终结果证明DROIDREACH模型识别结果正确。

## 4、限制

（1）适用ARMv7架构代码

（2）假设开发者在编译时静态定义JNINativeMethod，将其放在全局数据部分，对自定义加载程序或打包库的使用案例需要修改

（3）无法论证道路的可行性，很多操作无法复现

（4）模型利用ICFG表示代码结构，这种表示有可能在架构与传统ANDROID编程环境不符时并不充分。



