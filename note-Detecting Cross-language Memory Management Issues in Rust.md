# Detecting Cross-language Memory Management Issues in Rust

## 一、综述

Rust作为一种系统编程语言，以其强大的类型系统和独特的所有权机制避免了大部分的内存安全问题。然而在Rust中通过FFI（Foreign Function Interface）实现跨语言调用是不安全的。**本文揭示了任何错误使用FFI的行为都很容易导致内存安全问题和内存管理问题，并提出了一种利用静态分析自动化进行的漏洞检测工具——FFIChecker。**

## 二、简介

Rust是一种新兴编程语言，有高安全性和高性能的特点。很多安全导向的组件都在利用Rust进行重写，很多新的Rust项目也会调用C/C++第三方库来避免重复造轮子。

然而**在Rust中使用FFI调用外部函数是不安全的，因为Rust编译器无法对其它语言编写的代码进行安全检查**。开发者对FFI的错误使用可能会带来更多漏洞，从而违背使用Rust语言的本意。即使是使用纯Rust编写的软件也依然会受到影响，因为他可能依赖其他使用FFI的Rust软件包。

为了保护FFI的使用，Rust社区提供了**不安全代码的编写规范以及一些自动生成FFI的工具**，但这些只能帮助用户编写正确的接口和使用正确的数据类型，**在跨语言场景下的堆内存管理仍然存在问题**，且由于**Rust独特的所有权系统进行内存管理的模式，导致其内存安全问题相较于其他跨语言场景具有独特性。**

**在本文中，作者研究了Rust在跨语言场景下的堆内存管理问题，尤其是由Rust的所有权系统和C/C++的手动内存管理相结合导致的安全问题。同时实现了FFIChecker，一个基于静态分析的漏洞检测工具，他会收集Rust和C/C++代码的中间表示（IR），进行静态分析后输出诊断报告。实验结果表明，FFIChecker可以在可接受的时间和精度内正确检测出现实中的内存安全问题。**



## 三、背景知识

### 1、Rust所有权机制和跨语言内存管理

所有权系统可以看成一个自动内存管理系统，在所有权系统下每一个值都有自己唯一的所有者来记录自己的生命周期，当**所有者离开自己的作用域后这个值的内存将被清理。每个值的作用域在编译时就被决定**，因此Rust编译器可以将适当的内存回收例程插入到生成的二进制文件中。

当需要把一个值传递到程序的其他部分时有三种方法：

（1）拷贝/克隆

> 适用于简单数据类型例如整数，具有语义，即复制其字节是创造真实副本的有效方法

（2）移动所有者

> 适用于复杂数据类型，尤其是内部使用了堆内存的类型，例如向量vector
>
> 一旦多有权被移动，旧的所有者就会失效

（3）借用所有者

> 暂时通过引用访问一个值而不改变其所有者
>
> 只读值可以多次不可变地引用；当值可写时，一次只允许一个可变引用

Rust所有权机制能够保证一下两方面的安全问题：
（1）**所有权系统记录值的生命周期，保证引用的生命周期不超过原本值的生命周期。**因此**悬空指针**引起的内存安全问题可以被避免，例如**use-after-free**类问题。

（2）所有权系统**消除了可变别名，因此竞态读写带来的安全问题被避免**，例如竞争条件（两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题）和迭代器失效（突然指向垃圾数据）

由于C/C++的手动内存管理显然不安全，**本文只考虑堆内存在Rust中申请并通过FFI传递C/C++的情况。**其中有两种实现方式：
（1）借用堆对象，将它的引用传递给FFI

> 所有权保留在Rust一侧，所有权系统负责堆内存的释放

（2）移动所有权到FFI

> Rust的所有权系统忘记这块堆内存的存在，将他通过指针传递到FFI，由开发者负责内存释放

### 2、FFI造成的内存安全和内存管理错误

#### （1）内存损坏memory corruption

堆内存被FFI传递到外部函数，由开发者负责内存管理，此事**C/C++中常见的内存安全错误**都有可能发生，例如use-after-free,double-free,内存泄漏(已动态分配的堆内存由于某种原因程序未释放或无法释放)等问题。

#### （2）异常安全exception safety

Rust不支持try-catch语句处理异常。

```
try {
    逻辑代码块1;
} catch(ExceptionType e) {
    处理代码块1;
}
```

> 如果 try 语句块中发生异常，那么一个相应的异常对象就会被拋出，然后 catch 语句就会依据所拋出异常对象的类型进行捕获，并处理。处理之后，程序会跳过 try 语句块中剩余的语句，转到 catch 语句块后面的第一条语句开始执行。
>
> 如果 try 语句块中没有异常发生，那么 try 块正常结束，后面的 catch 语句块被跳过，程序将从 catch 语句块后的第一条语句开始执行。

Rust采用一种更可靠的异常处理机制：
对于所有**可恢复的错误**（典型案例是文件访问错误，如果访问一个文件失败，有可能是因为它正在被占用，是正常的，我们可以通过等待来解决），程序员必须处理或将错误返回给上层函数，由上层函数处理。

对于所有**不可恢复的错误**（由编程中无法解决的逻辑错误导致的，例如访问数组末尾以外的置），程序将终止执行并做栈展开（stack unwinding——在运行时期间从函数调用栈中删除函数实体），所有栈中的析构函数将会被执行，以防止内存泄漏。

然而当需要将Rust内申请的内存传递给外部函数时，程序员往往需要**暂时创建不健全的内存状态**（unsound state——例如使用未初始化的内存），当**外部函数执行完后，程序员再去清理这个状态以消除不良影响。如果有异常在这期间发生，程序终止执行并做栈展开，导致后续清理操作不会被执行。未被清理的不健全内存状态将长期存在造成安全漏洞。**

#### （3）混合内存管理机制mixing memory management machanisms

C库通常使用malloc和free来分配和释放内存，为了使用已有的库，Rust开发者需要将这些C库进行封装，这时可能会发生**错误混合使用不同语言的内存申请/释放。**例如在Rust中利用box申请堆内存而在C中通过free释放堆内存，这样的混合使用不同语言的内存管理机制是一种未定义行为，因为：Rust和C/C++可以使用不同的内存分配器，Rust在创建/释放对象时会运行其构造函数和析构函数，而C的内存管理没有类似的概念，只处理原始内存。

## 四、FFIChecker

本模型使用静态分析因为静态分析可以检测出程序中所有的控制流并捕捉潜在的bug。它特别适合捕捉特殊情况下的缺陷，因为它们很难被常规执行路径触发。

**总的来说，给定一个软件包（假设包含了Rust和C/C++代码），FFIChecker首先将Rust和C/C++代码分别编译成LLVM中间表示（LLVM IR），然后在LLVM IR上执行静态分析，跟踪每一块Rust中申请的堆内存的数据流转移和它的状态，即它是否被借用（borrow）或移动（move）。最后，如果一块堆内存被FFI传递给外部函数，FFIChecker继续分析这个外部函数，判断这块堆内存是否被外部函数释放。基于堆内存的状态，就可以判断它是否被正确地管理。例如如果堆内存被移动（move）至FFI，而且未被外部函数释放，那么这将会是一个内存泄露（Memory Leak）。再如一个堆内存被借用（borrow）至FFI，但在外部函数中被释放，那么这将会是一个Double-free或Use-after-free。**

**（1）用户界面：输入Rust包（包含rust crates和C/C++源文件），利用Cargo工具下载该Rust包中的crates所依赖的所有crates用于一起分析，分别利用Rust或C/C++编译器将源文件编译为LLVM IR，并收集程序入口点。**

**（2）入口点和外部函数收集器：由于公共函数对攻击者是可见的，因此选取公共函数/方法作为入口点。foreign function collection则需要收集公共函数/方法列表以及被Rust调用的C/C++函数列表。具体实现为：遍历Rust编译器生成的Rust高级中间表示（HIR），这其中包含了我们需要的信息，例如函数名，可见性visibility以及实现语言（C/C++ 或者Rust）；随后，提取所需的函数名称并将其传递给静态分析器。**

**（3）静态分析和漏洞检测模块：遍历LLVM bitcode提供的控制流图CFG进行分析。静态分析结束后，漏洞检测模块根据用户定义的规则来读取分析结果给出诊断信息。**

> ### 1、user interface用户界面
>
> 目标是**得到被分析的Rust包，并准备所有用于静态分析的成分**，例如LLVM位码和一组适当的入口entry point。随后他将其他进程委派给其他组件。**user interface以Rust包作为输入，Rust包包含一个或多个Rust crates**（一个编译单元，链接到Rust编译器，包含一个或多个Rust源文件，并且可能和其他Rust crates存在依赖关系）**以及C/C++源代码**。我们利用Cargo解决依赖问题并下载所有相关的crates，随后不同的源文件被分配到不同的编译器（Rust或C/C++编译器），两种编译器都将生成LLVM bitcode位码。
>
> ### 2、entry point and foreign function collection
>
> 执行静态分析需要适当的功能作为入口点。我们关注**Rust 程序的公共函数/方法**，并区分函数是由Rust还是C/C++编写的。在用户界面下载了所有依赖后，**收集器将处理这些crates并收集：**
> **（1）记录公共函数/方法的列表**
>
> **（2）记录被引入Rust程序的C/C++函数的列表**
>
> **收集器被实现为Rust编译器的自定义回调函数，以便访问编译器的内部数据结构。首先，他将遍历Rust编译器生成的Rust高级中间表示（HIR），这其中包含了我们需要的信息，例如函数名，可见性以及实现语言（C/C++ 或者Rust）；随后，他提取所需的函数名称并将其传递给静态分析器。**
>
> ### 3、static analysis and bug detection
>
> 静态分析的输入是LLVM bitcode，入口entry point和外部函数foreign function，静态分析通过遍历LLVM bitcode提供的控制流图CFG进行分析。静态分析结束后，漏洞检测模块根据用户定义的规则来读取分析结果给出诊断信息。
>

## 五、抽象解释

### 1、LLVM IR,抽象值和抽象域

用于捕捉内存状态！

在LLVM IR中，**一个函数被建模为一个控制流图CFG**，其中每一个节点表示一个不包含跳转的block。在每个block的结尾都有一个终结者，一条代表跳转的特殊指令。**静态分析将一个程序在一个抽象域内建模，该域内的每个元素表示程序的某个执行状态，称为抽象状态**。他**首先给每个变量和基本block分配抽象状态，然后遍历CFG并根据每条指令的语义更新这些状态**。

根据不同的目的抽象域也有多不同。为了**获取堆内存的所有权状态**，我们如下设计抽象域：

对于每个CFG，我们将<u>所有在该CFG中出现的变量定义为VAR</u>，将该CFG中出现的<u>所有基本block定义为BLOCK</u>。为了**区分一个变量是否存储了堆内存并确定所有权机制的状态**（是否被移动或者借用），我们定义了一个有五个元素的状态**MState**。

<u>最底部的元素是所有变量的初始值，当一个变量被堆内存分配初始化后，记录他的状态为Alloc，当堆内存通过引用访问的方式传递到FFI时记当前的状态为Borrowed，当堆内存通过忘记他的所有权传递到FFI时记录当前的状态为Moved，当当前状态无法被确定时，将其记录为顶部元素。</u>

为了跟踪每个基本块b的抽象值，我们构建一个Var到MState的查找表Omega b，记录block b执行完后所有变量的状态。所有Omega b的集合构成了抽象状态AState，因此AState内的一个元素就是一个查找表，表示该块内的所有指令执行完后所有变量的抽象状态。

抽象状态AState定义为从Var到MState的所有映射组成的映射格。直观地说，AState 中的元素是一个查找表，它描述了执行程序的当前基本block后每个变量的抽象内存状。

抽象域被定义为一个从BLOCK到AState的映射，也就是AState的powerset（完全子集）

### 2、transfer function

在静**态分析中，转移函数被用于从程序的语义中抽取信息并更新抽象状态**。由于FFIChecker运行在LLVM IR上，我们遵从以下规则根据语义给每个LLVM指令分配转移函数：

（1）**影响数据流**的指令，因为我们要传播抽象状态

（2）**调用**其他函数的指令，因为我们要通过他们来进行上下文相关的过程间分析

## 六、算法

### 1、fixed-point Algorithm

和其他静态分析工具一样，**FFIChecker遍历一个给出的CFG然后递归的运行转移函数来更新抽象状态，直到他达到了一个固定点。**这一部分的实现使用了经典的**worklist算法**

> worklist算法：
>
> 初始化后将未知数放入worklist中，从worklist中以某种形式抽取一个未知数，记录此时未知数的值，挑出以此未知数作为因变量的方程并进行运算，如果未知数的值发生改变那么将所有以该未知数为自变量的因变量插入worklist中。

工作列表W初始化为包含CFG中所有基本块的集合，随后该算法从W中选择一个基本块b，通过执行他的指令的转移函数来分析他，状态通过加入b的所有前驱predecessors的状态进行更新。如果状态变化，那么b的所有后继将被插入到工作表中等待重新分析。这些工作将被重复执行直到工作表变成空的。

### 2、analyzing function calls

函数调用时进行**进程间分析**。

将不同函数进行分类：

（1）分配堆内存的函数：这些是污点来源taint sources，意味着当前变量存储了堆内存，因此将其抽象状态设置为Alloc

（2）借用引用borrow reference或删除所有权remove ownership的函数：抽象状态为Borrowed或Moved。

（3）通过FFI调用的外部函数：这些函数是FFIChecker关注的可能带来漏洞的函数，因此FFIChecker会分析这个函数并确定是否会带来漏洞

（4）LLVM内部函数和Rust 标准库函数：**不注意**，在内部维护此类函数与其函数之间的映射处理程序，并将执行处理程序，而不是启动新函数分析。

（5）所有其他函数：通过**为这个函数初始化新的定点算法实例**来启动上下文相关过程间分析。

### 3、bug detection and false positive suppression

检查是否存在堆内存被传递到FFI的情况，如果有则一些堆内存泄漏到了外部代码中，可能带来漏洞。

如果**FFI是borrowed状态且C代码可见**，如果释放内存则会带来

**如果堆内存被移动（move）至FFI，而且未被外部函数释放，那么这将会是一个内存泄露（Memory Leak），如果被通过free（）释放，那么这将会是一个混合内存释放行为（Unfined behavior）；再如一个堆内存被借用（borrow）至FFI，但在外部函数中被释放，那么这将会是一个Double-free或Use-after-free。**

## 七、结果评价

为了评估FFIChecker的效果，作者从Rust官方包管理网站crates.io上抓取同时包含Rust和C/C++的软件包，最终收集到987个软件包（共包含了3, 232, 574行Rust和46, 321, 573行C/C++）。FFIChecker经过分析，产生了222个错误报告，经作者人工检查，确认了其中12个软件包中34个漏洞（19个内存泄露，3个异常安全错误，12个未定义行为）。性能方面，分析所有987个软件包共花费了5.2个小时，分析过程中最高内存占用为4.1GB。

导致错误的原因：
（1）Rust**调用动态链接库，此时外部代码的LLVM IR是不可见的，模型无法进行进一步分析，导致精度下降。**

（2）模型不能总是通过LLVM IR区分borrow和move，因为borrowing/moving操作可能会被Rust编译器优化。

并且，模型不能找到在包中仅实现而没有使用的通用函数的LLVM IR。

## 八、讨论

1、内存泄漏在检测出的漏洞中数量最多，这是因为在Rust中内存泄漏被认为是安全的。

2、未来工作：模型可以延展到其他跨语言领域，尤其是静态分析模块，只要FFI支持LLVM后端的代码生成那么该模块就可以直接使用。

