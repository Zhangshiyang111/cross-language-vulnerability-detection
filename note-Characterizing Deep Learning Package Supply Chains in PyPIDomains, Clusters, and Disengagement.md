# **Characterizing Deep Learning Package Supply Chains in PyPI:Domains, Clusters, and Disengagement**

## 一、摘要

深度学习框架包的安装依赖关系（在包的分发元数据中记录）：DL包供应链 DL SCs

探讨了两个具有代表性的PyPI DL包SCs中的包的域、集群和脱离参与

**域domain**：包的域是指包可以解决的任务类型

> 帮助了解一个包的强处，弱点和通常使用的场景

**集群cluster**：DL包SC是一个复杂的图，包含许多相互依赖的包。

> 集群帮助识别能够吸引其他包的关键包，同一集群中的包可能共享类似的功能

**脱离disengagement**：一个包脱离上述两个SC（tensorflow，pytorch）的程度和原因

如果一个包从某个版本开始完全删除了对DL框架及其依赖项的依赖，则称该包脱离了SC

**做法**：

1、分析近600万个PyPI包发行版的元数据，构建了一个对生态系统和版本敏感的安装依赖数据库

2、在数据库的基础上，通过迭代检索声明直接或间接依赖于tensorflow或PyTorch的包来构造tensorflow和PyTorch的SC

3、通过两个SCs中流行的包的描述（以每月下载的数量来衡量）进行主题分析，确定了34个包域，跨越八个类别（*Applications*, *Infrastructure*,and *Sciences* categories）。

4、采用Leiden社区检测算法检测集群

5、脱离这两个SC的包呈现上升趋势，总结出了与三个方面相关的七个脱离原因：依赖性问题、功能改进和安装的方便性

## 二、模型原理

**1、首先构建一个依赖数据库D：**

（1）PyPI包分发在其元数据的requires_dist字段中指定其安装依赖关系。该字段中的每个项都包含一个包名和一个可选的版本约束.

（2）根据python提供的packaging包构造了一个版本约束分析器。通过查询元数据，将所有满足版本约束的包插入D中。

**2、根据D构建SC：**

（1）对于每个包，维护一个属性，这是一个存储该包出现在SC中的所有版本的列表。

（2）对于每个依赖关系，维护一个属性，该属性使用映射来存储包Pu与其依赖Pa之间的版本依赖关系

**3.运用算法迭代构建SC**

输入：一个包名的列表(因为一个框架可能有多个报名，tensorflow,tensorflow-cpu,tensorflow-gpu)

unvisited列表：每次迭代时获取当前unvisited列表中所有包的直接依赖包，插入unvisited列表。初始化为输入包在PYPI中发布的所有版本。（这一步相当于构建了D）

对于unvisited列表中每个包的每个版本，从D中查询直接依赖于它的软件包的所有版本，将依赖关系加入E。迭代直到unvisited列表为空。

> **构建SC结果**：
>
> 1、TensorFlow SC包含2567个包，19116个版本和3232条边；PyTorch SC包含3278个包，26563个版本和5440条边。
>
> 2、与之前的工作相比：本文构建的SC中包含了更多的包（772），且这些包中有更多的下载量超平均的流行包（185）以及被依赖的包（85）。
>
> 3.关于依赖包实际未使用的问题：根据95%置信水平，5%置信区间各提取300+包进行测试，发现依赖包实际未使用问题较为罕见（7个（334个）和6个（344个））

## 三、实验

### RQ1 tensorflow和pytorch覆盖了哪些领域

只关注两个SC中的流行包，因为每月下载的次数越多，说明包或包的依赖者越多，这可以更好地反映SC的核心功能。

在TensorFlow和PyTorch SC中分别获得了219个和259个包，可用于人工标记。

通过**主题分析**来确定包域

1、检查每个包的摘要、描述和存储库自述文件，以收集有关其域的相关文本。

2、独立地读取和重读所有材料，生成描述每个包域的初始代码，并将类似的代码合并到主题中

3、比较代码和主题列表，直到达成协议，并为每个标识的代码开发一个包含定义和示例的编码指南

**结果：**

1、以两个SCs的每月下载量来衡量的流行包涵盖了34个域，属于8个类别。

2、这两种SC中超过85%的包属于应用程序、基础设施和科学类别。(*Applications*,*Infrastructure*, and *Sciences* categories)

3、PyTorch SC提供了更高比例的应用程序包，如NLP和CV。TensorFlow SC支持MLOps平台等基础设施包。

这表明TensorFlow SC和PyTorch SC在应用程序和基础设施领域各具优势。

### RQ2 在两个SC中形成了什么类型的包集群

因为SC是一个有向图，因此使用图社区检测技术将SC的复杂结构分解为包集群。

为了评估SC中派生包的影响。将**根节点**（即TensorFlow和PyTorch框架）及其**连接边**从进一步分析中**删除**，此时的孤立节点在SC中唯一依赖的是DL框架。

在修剪后的SCs上运行**莱顿社区检测算法**

> 集群的形状描述了集群内的包总体上是如何相互依赖的
>
> 集群的平均程度表示集群中包的依赖关系的平均数量。它们可以很好地反映软件包如何通过依赖关系参与SC。
>
> 集群大小指的是集群中的包的数量，并有助于识别增加SC中的包参与度的包。

利用包igraph将所有集群可视化为图

**结果：**

Leiden算法分别在修剪后的TensorFlow和PyTorch SC中检测131个和100个包集群。

集群主要呈现四种形状：箭头、星形、树形和森林，依赖的复杂性不断增加。

> **1、箭头集群**只包含两个软件包，其中一个取决于另一个。这些集群中的包并不依赖于其他集群中的包。
>
> **2、星团**呈现一个集中的形状，包含至少三个包，其中一个包依赖于其余的包。大多数星团包含不超过5个星包。
>
> **3、树**集群呈现具有根包的层次结构，集群中的其他包直接或传递依赖于根包。两个SC中最大的集群都是这种形状。
>
> **4、森林**集群显示了更复杂的层次结构，包中的其他包依赖于多个根包。

1、树和森林集群约占集群的22.9%和43.0%，包含了大部分（70.7%和92.9%）的包，这表明少数包吸引了大多数包到SC。

2、PyTorch SC中树和森林集群的比例较高，这表明PyTorch SC在包之间比TensorFlow SC具有更复杂的依赖关系。

3、大型集群的核心包往往是任何一个SC中的官方包，并展示了每个SC的（目标）专长。

### RQ3 多大程度以及为什么包会脱离SC

从包的代码存储库中确定了脱离的原因，因为代码存储库文档记录了丰富的开发活动数据（e.g..commits、问题、拉请求和发布说明）

**脱离原因：**

1、**不兼容性**

2、不使用完全依赖项导致的**膨胀**

3、追求更优**功能/性能**、

4、**简化**。一些包简化了各种包提供的繁琐功能。

5、**独立于框架**，从而支持更多框架

6、**灵活性**。脱离SC简化安装过程

7、安装**尺寸修剪**。

![image-20240206160931156](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240206160931156.png)

1、任何一个SC中脱离的包的数量都呈上升趋势。

2、包脱离SCC有七个原因：**依赖性问题、功能改进和易于安装**。

3、TensorFlow SC中最常见的脱离原因是依赖不兼容性问题，PyTorch SC中是为了简化功能和减少安装大小，这表明不同DL SC中的包面临不同的依赖管理问题。