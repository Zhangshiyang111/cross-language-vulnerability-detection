# ATVHUNTER: Reliable Version Detection of Third-Party Libraries

## 一、摘要

 检测第三方库对于下流任务例如恶意软件和重打包软件的识别至关重要。为了识别嵌入app中的第三方库，我们需要克服TPL依赖性，代码混淆，精确版本表示等挑战。

**因此我们提出了ATVHUNTER，他可以精确指出嵌入APP的脆弱TPL版本，并提供关于TPL和漏洞的具体信息。首先使用类依赖关系从主机应用程序中分离出独立的候选TPL模块，并采用两阶段的策略来识别应用程序内的TPL。第一阶段：提取控制流图进行粗粒度分析从而在预定义的TPL数据库中匹配可能的TPL。第二阶段：从每个控制流图的基本块中提取指令操作码进行细粒度分析从而确定该TPL的准确版本号。**ATVHUNTER已经集成为在线服务的一个分支，以帮助用户识别易受攻击的安卓TPL。

为了确保召回率，我们通过从maven存储库中收集全面和大规模的Java库来构建TPL特性数据库。我们使用**模糊哈希方法**来生成签名，这可以减轻代码混淆的影响。与以前的方法相比，ATVHUNTER不依赖于软件包的结构。**目前，我们已经构建了一个全面、大规模的TPL特征数据库，其中包括189545个TPL，对应3006676个版本来识别应用内TPL。**我们还构建了一个脆弱TPL版本数据库，包含152个开源TPL的4533个受影响版本，涉及1180个CVE报告和224个安全性bug。

实验数据表明ATVHUNTER比SOTA算法表现更好，兼具高准确性（90.55），高召回率（88.79），高效率，对代码混淆技术的高弹性和高可移植性。

我们利用ATVHUNTER对73110个应用程序进行了大规模研究，发现9050个应用程序包含10616个易受攻击的TPL。这些易受攻击的TPL包括53,337个已知漏洞known vulnerability和7,480个安全漏洞security bug。它们中的大多数都使用包含严重漏洞的TPL。



## 二、困难与挑战

由于许多TPL被分散在不同的APP中，APP中运用的TPL组件信息并不透明，TPL之间存在许多直接或简介的依赖，因此很多时候开发者并不知道自己引入了存在漏洞的TPL。正因如此，漏洞TPL识别十分必要。

**TPL版本检测已成为一种标准的行业产品，被称为软件组成分析SCA。**

现存的TPL检测技术多依赖聚类算法clustering-based methods和相似性对比技术similarity comparison methods。但**这两种方法都存在一下不足之处**：

（1）低召回率：

聚类算法只能识别常用的TPL，对针对特定客户的和新的TPL识别效果差。不同TPL以及同一TPL的不同版本的代码相似性可能会有所不同，这使得聚类算法难以选择合适的参数来完美地区分不同的TPL，甚至是同一TPL的不同版本。验证聚类结果也是一个劳动密集型的和容易出错的问题。

相似度比较方法构造了一个预定义的TPL数据库作为参考数据库。然而，目前发布的TPL数据库的规模远远小于实际市场上的TPL的数量。同时，现有的技术或多或少依赖于包结构package structure，特别是使用包结构来构建应用程序内的候选库。然而，不同版本的相同TPL的包结构/名称可能是突变的或容易混淆的。因此，使用软件包作为补充特性来生成TPL签名也是不可靠的。

（2）无法准确识别TPL的版本

（因为同一个TPL不是每一个版本都存在漏洞）

除了上述缺陷，**TPL版本识别还面临着一些挑战：**
（1）缺少漏洞TPL版本数据集

理想中的数据集，对于每一个包含漏洞的TPL，应该提供TPL的名字，版本，类型，漏洞严重程度等信息。

（2）精确版本表示

提取适当的代码特性来表示同一TPL的不同版本是具有挑战性的，特别是当不同版本的代码差异很小时。

（3）代码混淆干扰

例如，删除死代码可以在不被主程序调用的前提下删除代码。这些技术可以改变原始TPL和嵌入APP的TPL之间的相似性。

## 三、相关工作

1、库检测

2、漏洞TPL/APP识别

目前，有三种基于聚类算法的TPL检测工具：LibRadar, LibD,LibExtractor

LibRadar提取安卓API调用、API调用总数和API调用类型作为代码特征，并选择多层次聚类方法来识别潜在的TPL。

LibD提取每个CFG块中的操作码作为代码特性。

LibExtractor利用基于聚类的方法来寻找潜在的恶意库。

但他们都存在一下弱点：

## 四、模型结构

将一个安卓APP作为输入，根据构建的数据库自动识别使用的脆弱TPL的版本。系统设计主要分为两个部分：

（1）TPL版本检测，它识别应用程序使用的TPL的特定版本

（2）脆弱TPL版本检测，它根据我们从NVD 和Github中收集到的已知漏洞来识别脆弱的应用内TPL版本。

### 1、TPL检测

TPL检测分为四个阶段： (1)预处理、(2)模块解耦(3)特征生成(4) TPL识别。

#### **预处理：**
此步骤主要包含两个任务：

（1）第一个任务是反编译输入应用程序，并将字节码转换为适当的中间表示形式（IRs）.

（2）第二个任务是在应用程序中找到主模块并删除它，以消除来自主机应用程序的干扰。（TPL为非主，其余应用程序代码为主模块）

具体实现步骤：
首先解析AndroidManifest.xml文件并获得主机应用程序包。有时，主机应用程序的代码可能属于几个不同的名称空间，因此我们需要提取应用程序包、应用程序名称空间和包括主活动的包名称空间，并在主机命名空间下删除这些文件。

> 部分主机代码遭受包扁平化或重命名混淆，不能删除。
>
> 由于包名特殊，无法删除部分主机代码。
>
> （如果主机代码和TPL没有依赖关系，则不会影响TPL识别的准确性。如果未删除的主机部分包含TPL，我们可以在比较阶段消除干扰。）
>
> 主机应用程序和TPL具有相同的包名称空间，该方法可能会删除这些TPL，导致假阴性。

#### **模块解耦：**
目的是将一个应用程序的非主模块分解为不同的独立候选库。

许多不同的TPL共享相同的根包root package

> com.android.support.appcompat-v7”和“com.android.support.design”

一个TPL可能有多个并行包结构

> 这个TPL依赖于其他TPLs来构建自己，而开发人员部署“Fat”jar模式来打包这个项目。

主机TPL和所有被调用的TPL一起构建了完整的TPL。

**为了克服这个问题，我们采用了类依赖图（CDG）作为拆分候选TPL的特征，因为CDG不依赖于包的结构，它对包的扁平化具有弹性。**

**类依赖关系**包括： 1)类继承，我们不考虑接口关系interface relationship，因为它可以在混淆中被删除。2)方法调用关系。3)字段引用关系field reference relationship。

我们使用CDG来查找所有相关的类文件，每个CDG将被视为一个候选TPL。

在ATVHUNTER中，我们**使用基于相似性的方法来识别TPL-Vs**，我们使用从maven存储库下载的完整TPL文件来生成TPL特性数据库。

**关注Java项目的打包技术:**

> 大多数开发人员通常采用“skinny”模式来打包TPL，这意味着发布的版本只包含TPL开发人员的代码，而没有任何依赖的TPL。在编译期间将加载依赖项TPL。

为了解决这种情况，我们抓取每个TPL的元数据，并通过读取“pom.xml”文件来记录它们的依赖性TPL和打包技术.如果“pom.xml”声称“jar with-dependencies”，这意味着它包括所有依赖的TPL，否则，它只包含主机TPL代码。如果我们找到了一个精简的jar，我们还需要使用它们的包名称空间来分割它们的依赖性TPL，这样我们就可以在TPL数据库中匹配正确的版本。

#### **特征生成：**
在拆分候选库之后，我们的目标是提取特征并生成签名signature来表示每个TPL文件。为了兼顾可扩展性和准确性，同时保留粗粒度特征和细粒度特征。粗粒度特性用于帮助我们快速定位数据库中潜在的TPL，细粒度的特征被用来帮助我们精确地识别TPL-V。

> 粗粒度：提取控制流图进行粗粒度分析从而在预定义的TPL数据库中匹配可能的TPL。细粒度：从每个控制流图的基本块中提取指令操作码进行细粒度分析从而确定该TPL的准确版本号。

粗粒度特征提取具体实现：

>  我们首先为候选TPLs中的每个方法提取CFG，并遍历该CFG，根据执行顺序为每个节点分配一个唯一的序列号（从0开始）。对于序列号为n的分支节点，其输出边较多的子节点序列号为n + 1，另一个子节点序列号为n + 2。如果两个子节点具有相同的传出边，我们将给在基本块中具有更多语句的子节点设置序列号为n+1。
>
> 然后，我们根据每个节点分配的序列号将CFG转换为签名signature，以表示每个唯一的TPL，以[节点计数，边邻接列表]的形式，其中邻接列表表示为：[父1->（子1，子2，...），父2->…]。
>
> 然后我们将CFG的邻接列表作为方法签名method signature。为了提高搜索效率，我们将这些哈希值按升序排序，然后将连接值哈希为粗粒度的TPL特征之一（T1）。同时，我们还在数据库中保留了一系列的CFG签名signature，以表示特征数据库中的每个TPL。

细粒度特征提取具体实现：
粗粒度特性（即CFG）可能生成不同版本的相同签名，因此提出细粒度特征，即在CFG的每个基本块中的操作码，来表示每个版本文件。但是增加了计算复杂性和计算资源的使用。为了保证可扩放性，使用hash方法。但是传统hash方法在确定两者相似性时具有显著的缺点，就是一个小的修改可能会导致哈希值的巨大变化。

因此，本文选用模糊哈希技术fuzzy hash technique为每个method生成code signature。

> 首先，提取每个基本块中的所有操作码序列，并将它们连接在一起。（不考虑的操作数，例如标识符名称或硬编码的url等，因为一些简单的混淆技术就会让他们不稳定）
>
> 然后，我们根据CFG的邻接列表连接每个基本块的所有操作码序列。我们使用了对每个方法级特征的模糊散列和相似度比较来找到相似的方法。我们首先使用一个滑动窗口（也就是滚动哈希）来将操作码序列切成小块。如果特征的一部分由于代码混淆而发生变化，则不会对最终的fingerprint造成很大的差异。然后，我们对每个片段进行散列hash，并将它们组合为每种方法的最终细粒度指纹fingerprint。
>
> 一个版本中所有method的fingerprint联合起来就代表了这个TPL 的版本。

#### **TPL数据库构建：**

> 从Maven存储库（189,545个独立TPL及其3,006,676个版本）中抓取所有JavaTPL来构建我们的TPL数据库。
>
> 使用上述方法来获得每个TPL的签名。对于每个版本的TPL，我们将粗粒度和细粒度的特性存储在MongoDB数据库中。

#### **库识别：**

在一个给定的应用程序中识别所使用的TPL-Vs。

为了提高效率，本部分分为两个阶段： 1)潜在的TPL识别；2)版本识别

#### 潜在的TPL识别

为了提高搜索效率，我们按照一下顺序搜索数据库：
（1）按软件包名称进行搜索。

> 对于每个候选库，我们首先使用它的包名称空间package namespace（如果没有混淆的话）来缩小数据库中的搜索空间。请注意，我们不能直接使用包名称来确定TPL，因为相同的包名称空间可能包含不同的第三方库。

如果包名已被混淆(如果一个包名是哈希值或单个字母，我们认为它是混淆的)，或者候选TPL模块没有包名，那么我们将转移到下一个过滤策略。

> 包名只是用作补充信息，以加快搜索过程。无论候选TPL是否可以通过使用包名在TPL数据库中找到匹配项，我们仍然会继续通过其他特性搜索TPL数据库。

(2)按类classes的数量进行搜索。

如果两个TPL内的类的数目相差较大，我们一般认为这不是同一个TPL。（如果一个TPL中的类数量只占数据库中另一个TPL中类数量的40%，则不进行下一步的比较）

（3）通过粗粒度特性进行搜索。

> 首先在TPL数据库中搜索粗粒度特征T1.
>
> 如果我们找到相同的一个，ATVHunter将报告这个TPL并停止搜索过程。
>
> 否则，ATVHUNTER将比较候选TPL和数据库中的TPL，如果所有的粗特征都相同，我们考虑找到TPL，搜索过程将停止。
>
> 如果超过70%的粗粒度特征是相同的，我们认为它是一个潜在的TPL。当我们找到潜在的TPL时，我们将确定其确切的版本。

#### 版本识别

利用细粒度特征，并计算两个TPL的相似度比作为评价度量。

ATVHUNTER可以在前一阶段记录相同的方法对，因此，我们只需要在这个阶段比较不到30%的方法。

因为一些代码混淆技术（例如，垃圾代码插入）会改变方法的指纹method fingerprint，从而导致最初相同的两种方法被识别为不同。因此，我们需要比较方法的相似度，仅当两种方法的相似度超过一定的阈值后认为这两种方法是匹配的。

根据匹配方法的数量，我们计算TPL相似度。当匹配方法的数量超过阈值时，我们认为我们找到了正确的TPL版本。

**方法相似性对比：**

使用编辑距离edit distance来衡量两种method fingerprint之间的相似性。

**编辑距离**：将一个fingerprint修改为另一个fingerprint所需的最小编辑操作（即插入、删除和替换）的数量。

基于两个signature的编辑距离，我们利用以下公式计算了两种方法（即ma和mb）之间的**方法相似度评分（MSS）**：
$$
% MathType!MTEF!2!1!+-
% feaahqart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn
% hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr
% 4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr
% pepC0xbbL8F4rqqrFfpeea0xe9Lq-Jc9vqaqpepm0xbba9pwe9Q8fs
% 0-yqaqpepae9pg0FirpepeKkFr0xfr-xfr-xb9adbaqaaeGaciGaai
% aabeqaamaabaabauaakeaacaWGnbGaam4uaiaadofacaGGOaGaamyB
% amaaBaaaleaacaWGHbaabeaakiaacYcacaWGTbWaaSbaaSqaaiaadk
% gaaeqaaOGaaiykaiabg2da9iaaigdacaGGTaWaaSaaaeaacaWGKbGa
% ai4waiaad2gadaWgaaWcbaGaamyyaaqabaGccaGGSaGaamyBamaaBa
% aaleaacaWGIbaabeaakiaac2faaeaaciGGTbGaaiyyaiaacIhacaGG
% OaGaamyBaiaacYcacaWGUbGaaiykaaaaaaa!5880!
MSS({m_a},{m_b}) = 1 - \frac{{d[{m_a},{m_b}]}}{{\max (m,n)}}
$$
其中，m和n表示两种方法的signature长度，d[ma，mb]为两种方法signature的编辑距离。如果MSS超过一定的阈值，则认为这两种方法是匹配的，基于后续实验，我们将这个阈值设置为0.85.

TPL相似度比较（TSS）：根据匹配方法的数量，将两个TPL（t1和t2）的相似性定义如下
$$
% MathType!MTEF!2!1!+-
% feaahqart1ev3aaatCvAUfeBSjuyZL2yd9gzLbvyNv2CaerbuLwBLn
% hiov2DGi1BTfMBaeXatLxBI9gBaerbd9wDYLwzYbItLDharqqtubsr
% 4rNCHbWexLMBbXgBd9gzLbvyNv2CaeHbl7mZLdGeaGqiVu0Je9sqqr
% pepC0xbbL8F4rqqrFfpeea0xe9Lq-Jc9vqaqpepm0xbba9pwe9Q8fs
% 0-yqaqpepae9pg0FirpepeKkFr0xfr-xfr-xb9adbaqaaeGaciGaai
% aabeqaamaabaabauaakeaacaWGubGaam4uaiaadofacaGGOaGaamiD
% amaaBaaaleaacaaIXaaabeaakiaacYcacaWG0bWaaSbaaSqaaiaaik
% daaeqaaOGaaiykaiabg2da9maalaaabaGaamytamaaBaaaleaacaGG
% 8bGaamiDamaaBaaameaacaaIXaaabeaaliabgMIihlaadshadaWgaa
% adbaGaaGOmaaqabaWccaGG8baabeaaaOqaaiaad2eadaWgaaWcbaGa
% aiiFaiaadshadaWgaaadbaGaaGOmaaqabaWccaGG8baabeaaaaaaaa!5605!
TSS({t_1},{t_2}) = \frac{{{M_{|{t_1} \cap {t_2}|}}}}{{{M_{|{t_2}|}}}}
$$
t1是测试应用程序中的TPL候选项，t2是数据库中的用于比较的TPL。

M|t2|是t2中方法的数量。|t1∩t2|是t1和t2匹配方法的数量

我们只比较两个所有方法的MSS均大于阈值，且至少有一个完全匹配方法的TPL（MSS=1），以加快识别过程。

如果TSS超过一定的阈值（根据实验设置为0.95），那么我们认为找到了TPL可能的版本。将相似度得分最高的版本认为是最终的结果，被提供提供标识的组id、件id和版本号（group id,artifact id and version number）。

### 2、脆弱TPL-V识别

我们首先构建一个易受攻击的TPL-V数据库，在此基础上我们识别应用程序使用的易受攻击的TPL-V。

#### 数据库构建

**已知的TPL漏洞Known TPL Vulnerability Collection**

为了收集脆弱的TPL版本，我们将我们的特征数据库中的所有TPL文件（总共300667个）转换为CPE格式（common platform enumeration ）,然后利用一个专业的CVE检测工具cve-search进行检测，从而通过映射转换过的TPL名称（mapping transformed TPL names）从公共CVE数据集中检测出脆弱的TPL。

通过这种方式，我们可以知道包含已知漏洞的TPL版本和相关的详细信息，包括CVE id，漏洞类型，描述，来自常见漏洞评分系统（CVSS）的严重程度评分、易漏洞版本等。

我们使用CVSS v3.0来指出本文中收集到的漏洞的严重性。最后，我们从957个独特的TPL中收集了1,180个CVE，包括38,243个受影响的版本。

**开源软件中的安全漏洞Security Bug Collection**

由于本模型可以识别出所使用TPL的具体版本，因此我们从GITHUB和BITBUCKET中收集了224个安全漏洞。这些bug来自于152个开源TPL及其相应的4,533个版本。所有这些安全漏洞都已被行业中的安全专家交叉验证。

#### 脆弱TPL-V识别

ATVHUNTER在识别出APP中应用的TPL-V后，将会搜索脆弱TPL-V数据库，从而确定是否调用了存在漏洞的TPL。如果发现调用了存在漏洞的TPL，则将生成一个详细的漏洞报告。

我们认为ATVHUNTER可以作为谷歌ASI项目的扩展。

### 3、具体实现技术

使用APKTOOL，一个逆向工程工具反编译安卓应用程序。

使用Androguard，获得类依赖关系，从而获得独立的候选TPL。

使用SOOT来生成CFG，并在SOOT上构建获得CFG的每个基本块中的操作码序列。

使用ssdeep来进行模糊哈希算法来生成代码特征。

使用编辑距离算法来找到应用程序内的TPL。

> 我们的方法可以精确确定特定的TPL版本。
>
> 我们维护了一个包含超过300万个TPL文件的库数据库，并构建了一个脆弱的TPL数据库，其中包括来自Github上的开源Java软件的224个安全漏洞，以及来自公共CVE数据库中的910个安卓TPL的1180个安全漏洞。

## 五、实验评价

首先构建ground truth，并为TSS和MSS选择合适的阈值。随后评价ATVHUNTER的有效性（RQ1）、可扩展性（RQ2）和代码模糊-弹性（RQ3）的能力。

### 1、ground truth数据集构建

 目的：

1)验证ATVHUNTER的有效性；

2)将其性能与最先进的工具进行比较；

3)向社区发布数据集，以促进后续研究。

做法：

我们首先从F-Droid上收集了500个开源应用程序的最新版本。对每个应用手动分析，从而获取应用内用到的TPL及其版本。

> 选择开源软件是因为可以在应用的配置文件和源代码中获得特定的TPL信息（包括版本），因此将应用和TPL之间的映射关系作为性能评估的ground truth。

通过分析可知，这些应用程序包含2-37个不同大小不同功能的TPL。随后我们从MAVEN存储库中下载这些版本的TPL。为了确保结果的可靠性，我们需要下载TPL的完整版本，也因此过滤掉了144个包含不完整TPL的应用程序。

通过我们的分析可知，先前使用的一些数据集存在一定的偏差。LibScout和LibID使用的数据集的TPL都是独立的，我们又加入了一些依赖于其他TPL的TPL，以揭示不同工具的lib识别能力。

最终，我们选择了356个应用程序和拥有6819个不同版本的189个独立unique的TPL作为ground truth。

### 2、阈值选择

为了避免偏差，除了前面的ground truth数据集外我们随机选择了三组每组200个APP确定MSS和TSS的合适阈值。我们使用method级别的假阳性率FPR和假阴性率FNR，以及TPL级别的FPR和FNR作为指标，通过改变不同的MSS和TSS阈值来确定合适的相似性阈值。我们使用这三组应用程序来实现三次相同的实验，然后确定最优阈值。

图一method级别不同阈值时的FPR和FNR，我们可以发现，当阈值在0.85左右时，FPR和FNR都相对较低。因此，我们选择 0.85作为MSS阈值，其中FPR小于1%，FNR小于0.5%，可以实现很好的权衡。

图二TPL级别不同阈值时的FPR和FNR，当阈值逐渐接近0.8时，由于相同的TPL的不同版本的微小变化，出现了许多假阳性。当阈值接近于1时，假阴性反应的数量就会增加。当阈值在0.95左右时，FPR和FNR实现了很好的权衡，因此我们选择0.95作为TSS的阈值δ。

### 3、有效性

将其与最先进的公开TPL检测工具（即LibID、LibScout、OSSPoLICE和LibPecker）进行比较。这些工具可以识别我们构建的ground truth数据集中的APP使用的TPL版本。**我们运用准确性，召回率和F1值作为评价标准来评价TPL级别和版本级别的识别准确性。**

> “okio-2.0.0，okio-2.3.0”，但基本事实是“okio-2.4.3”，对于TPL-level，我们认为该工具找到了正确的TPL；对于版本级别，我们认为有两个假阳性和一个假阴性。

考虑到整体性能，我们可以看到ATVHUNTER在所有指标上都优于其他工具。ATVHUNTER在TPL级和版本级的F1得分分别达到93.43%和88.82%。对于TPL级识别，我们可以发现它们都可以在TPL级识别上达到较高的精度，但目前最先进的工具的召回性能一般。

对于版本级识别，我们可以发现ATVHUNTER的精度（90.55%）和召回率（87.16%）远高于其他工具。与TPL级的精度相比，我们可以看到每个工具在版本级的精度降低了很大程度，这意味着他们中的大多数可以识别TPL，但他们不能确定准确的版本。

#### 假阳性：

**ATVHUNTER**

（1）开源组件的重用。一些TPL是基于其他TPL重新开发的，只有很小的代码变化，如果它们的相似性大于定义的阈值，则会出现假阳性。

（2）Artifact ID或组ID发生更改。我们通过组id、Artifact id和版本号来识别一个TPL。但是当一些旧版本的TPL已经迁移到新版本的，它们的组id或Artifact id被改变了，但是它们的代码没有什么区别。例如org.greenrobot是de.greenrobot的升级版本，两者代码具有很高的相似性，但具有不同的组id，因此被认为是不同的TPL。

（3）相似性较高的不同版本。相同TPL的某些不同版本的代码变化很小或没有区别。ATVHUNTER将同时报告两个版本的TPL，其中一个被认为是假阳性。在我们的数据库中，我们甚至发现相同的TPL的某些版本具有相同的Java代码，但具有不同的资源文件、配置文件或本地代码（C/C++），但这种情况并不影响易受攻击的TPL识别过程。

**LibScout**

代码特性code feature（fuzzy method signature）过于粗糙，如果两个版本有微小的差异，也会为不同的版本生成相同的signature。

如果method非常简单，那么由LibScout和OSSPoLICE生成的签名也会是相同的，这也会导致假阳性。

**LibPecker**

依赖于软件包结构作为一个补充特性来识别不同的TPL，它们可能会多次报告一个依赖于其他TPL的TPL。例如APP调用TPL-C，TPL-C建立在TPL-A和TPL-B上，则会将TPL-C报告为TPL-A和TPL-B，导致假阳性。

#### 假阴性：

**ATVHUNTER**

(1)在编译应用时，开发者可能会采取一些优化措施来减少应用的大小。其策略是编译器自动删除一些不被主机应用调用的TPL的功能，这导致应用内的TPL与原来的TPL不同，导致假阴性。

(2)一些TPL被集成到主机应用程序的同一包名称空间package namespace中，这可能会在预处理阶段被删除，导致假阴性。

(3)一些应用程序使用开源平台（如Github或Bitbucker）上很少使用的开源TPL，这些平台不在我们的TPL数据库中（超过300万个TPL），导致假阴性。

**其他方法**

或多或少地使用软件包结构来生成TPL特性。但是，包结构不稳定，很容易通过包扁平模糊来改变。

很难使用包结构和包名称来确保TPL候选，因此，现有的工具可能会为这些TPL生成不正确的代码特性。

> 与它们相比，我们的CFG邻接列表对CFG结构修改的影响不那么敏感。我们同时考虑了语法信息和语义信息，我们的方法采用模糊散列来生成TPL fingerprint。因此，代码语句的修改只能影响部分fingerprint，这对不同的代码混淆更健壮。

**特征的选择、提取和生成的策略是必不可少的，这可以直接影响系统的性能。ATVHUNTER优于最先进的TPL检测工具，在库级别达到98.58%的准确率，88.79%的召回率，在版本级别达到90.55%的准确率，87.16%的召回率。**

### 4、可扩展性

研究ATVHUNTER的检测时间，并将其与最先进的工具进行了比较，以验证其效率。

所有工具都使用相同的数据集（6819个TPL版本）构建自己的TPL数据库。所有比较工具都选择相似度比较方法来找到应用内TPL，因此检测时间主要取决于应用内TPL的数量和数据库中TPL特征的数量。

检测时间是在测试应用程序中查找所有TPL-Vs的周期成本，不包括数据库构建时间。

我们提出了四个指标（即Q1、平均值、中位数、Q3）来评估每个工具的效率。我们可以看到，ATVHUNTER的效率也优于最先进的工具（平均每个应用程序使用66.24秒）。ATVHUNTER比其他方法更有效，因为我们的方法在大多数情况下只需要直接搜索来找到匹配的对（采用两阶段策略进行匹配），这可以大大减少检测时间。

> 与其他工具相比，ATVHUNTER能够高效地识别准确的TPL-v，并且在ground truth TPL数据库上检测TPL的时间更短

### 5、代码模糊弹性

模糊弹性能力是衡量TPL检测工具性能的一个重要指标，因为模糊技术可能会降低检测性能。

考虑不同的模糊技术，我们从公共数据集中选用100个不同类别的APP，使用一个流行的混淆工具，Dasho，用四个广泛使用的模糊技术（即重命名模糊，控制流随机化、包扁平化和死代码删除）混淆这些apk。最后，我们得到了一组（100个应用程序）的原始应用程序和四组（100*4）的模糊应用程序。基于这些应用程序组，我们在版本级别上与其他工具的检测率detection rate（|TP|/|GT|）进行了比较。

**结果**

第二列为每个工具在原应用程序上的检测率。我们可以看到ATVHunter的检出率最高（99.26%），其次是LibPecker（98.79%）。此外，可以发现LibID的检出率仅为12.93%，与RQ1的结果存在很大的差距。我们发现造成这种差距的主要原因是LibID无法使用反编译组件dex2jar。

**重命名混淆**：我们可以看到所有工具对重命名混淆都有弹性，因为所有工具对重命名应用程序的检出率都与没有混淆的应用程序相同。

**包扁平化混淆**：对ATVHUNTER没有影响，说明ATVHUNTER对这项技术具有完全弹性，而其他方法对于这项混淆技术的效果都出现了不同程度的下降。相比之下，ATVHUNTER使用类依赖关系来分割不同的候选TPL（基于不同TPL之间的高内聚性和低耦合high cohesion and low coupling），这完全不依赖于包的结构，因此，ATVHUNTER对包的扁平化/重命名具有弹性。

**死代码删除**：删除一些没有被主机应用调用的代码，导致应用内TPL的代码特性与原来的TPL不同。LibPecker选择类依赖关系作为保持方法调用关系的代码特性，而我们采用CFG作为代码特性，他不包括方法依赖关系。我们的方法可以包括没有调用的方法和类。LibPecker的签名比我们的签名存储了更多的语义信息，因此LibPecker在删除死代码时取得了更好的性能。

**总结**

ATVHUNTER将CFG作为粗粒度特性，并在CFG的基本块中提取操作码作为细粒度特性。我们保留语义信息并删除操作数，这样我们的方法对标识符重命名具有弹性。我们将操作码序列分成小块，并利用模糊哈希生成代码特征，虽然死码清除混淆和控制流混淆技术会影响部分代码特征，但我们的策略有效地减少了干扰，使检测率仅仅略有下降。

ATVHUNTER受到所有这些代码混淆技术的影响较小。代码删除对ATVHUNTER的影响最大，检出率下降了约24%，而使用其他混淆技术的应用程序的检测率仍然超过90%。

**与现有的工具相比，ATVHUNTER提供了对代码混淆的更好的弹性，特别是在标识符重命名、包扁平化和控制流随机化方面。**

## 六、大规模实验分析

进一步对谷歌Play应用程序进行了大规模的研究，以揭示现实世界中脆弱的TPL-Vs的威胁。

从google play上根据安装数收集商业安卓应用程序，对从2019年8月到2020年2月的最新版本的应用程序进行了大规模实验，只考虑安装量在1万到50亿之间的流行应用程序。

我们最终收集了来自33个不同类别的104,446个应用程序作为研究对象，其中73110个应用程序使用TPL进行开发，因此我们专注于这73110个程序进行分析。

**漏洞TPL分析**

我们使用CVSS v3.0安全度量[53]来指示漏洞的严重程度（即低、中、高和关键）。得分大于7.0表示严重程度较高和最严重的漏洞，占我们数据集所有漏洞的21.35%。这些严重的漏洞通常涉及远程代码执行、敏感的数据泄漏、服务器端请求伪造（SSRF）攻击等。其中74.95%的漏洞被其他TPL广泛使用。这些脆弱的TPL大部分属于公用事业公司，占98.7%。

**脆弱TPLs的影响分析**

发现大约12.37%（9,050/73,110）的应用程序包括TPL-Vs，涉及53,337个已知漏洞和7,480个安全漏洞。

已知的漏洞来自166个不同的脆弱TPL，对应的10,362个版本，安全漏洞来自27个脆弱TPL，284个不同版本。

这些易受攻击的应用程序总共使用了58,330个TPL，其中约18.2%是易受攻击的TPL。

在9,050个易受攻击的应用程序中，有329个应用程序（37.5%）同时包含漏洞和安全漏洞。有778个应用程序包含带有安全漏洞的TPL，每个应用程序的TPL中包含大约2.45个安全漏洞。

**现实教训**

**TPL开发者**经常基于存在的TPL开发自己的TPL，但是很少检查使用的组件是否存在已知漏洞，导致了漏洞的进一步传播。

**应用开发者**：（1）大多数开发人员只关心TPL提供的功能，而不知道这些TPL中的安全问题。（2）应用程序开发者或公司不知道如何对这些输入的tpl进行安全检测。（3）一些应用程序开发者并不知道一些易受攻击的TPL已经更新或打了补丁，他们仍然使用这些旧的TPL版本。

**应用市场**：许多应用市场没有这样的安全评估机制来警告开发者他们的应用中的潜在安全风险。只有谷歌提供了一项名为应用安全改进（ASI）的服务。

## 七、不足

（1）如果多个版本的Java代码是相同的，那么ATVHUNTER将提供几个候选版本，而不是一个特定版本，从而导致一些误报。

（2）如果一些TPL被引入主机程序的包结构中，则他可能被ATVHUNTER作为主模块的一部分而误删，从而导致一些假阴性。

（3）我们只关注Java库，而不考虑本机库。事实上，本机库也是安卓应用程序的重要组成部分，其内部的漏洞会造成更严重的后果。

（4）ATVHUNTER采用静态分析来寻找tpl，因此，我们可能会错过一些以动态方法加载的库。

（5）第三方库一直在不断更新，这意味着ATVHUNTER找不到这些新出现的TPL。因此，如何找到这些新出现的TPL并动态维护我们的数据库将是我们未来的工作。

**有效性威胁**

（1）相似性阈值设置的合理性

（2）仅对免费应用程序进行的分析，未来将同时对免费应用和付费应用进行分析。

