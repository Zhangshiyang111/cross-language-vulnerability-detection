# NCScope：安卓app用于本地代码分析的硬件辅助分析器

# 一、摘要

越来越多的安卓app和恶意软件都依赖本地代码实现自己的功能。而难以以低成本获取和分析高保真度的执行路径和内存数据导致了不完整有偏差的分析结果。

**本文提出了一个安卓app用于本地代码分析的硬件辅助分析器，利用 ARM 平台的硬件功能 ETM，以及Android系统的内核组件eBPF，收集目标应用程序的真实执行路径和相关内存数据，并设计新的根据收集的数据仔细检查本机代码的方法。**

**为了展示NCScope的独特能力，我们将其应用于现有工具无法完成分析的四个应用程序，包括：在应用程序的本机代码中实现的（1）自我保护和（2）反分析机制的系统研究；（3）本机代码中内存损坏的研究（memory corruption）；（4）识别本机代码中函数之间的性能差异。**

分析结果表明，超过百分之八十的金融app没有自我保护机制，而将近百分之八十的恶意软件有反分析机制，这表明NCScope的使用十分必要。**并且NCScope还可以有效的在本机代码中检测bug和识别性能差异。**

# 二、简介

## 1、技术困难

本地代码分析的难点在于接收的动态特征阻碍了原生代码的静态分析；现存的动态分析难以以低成本获取和分析高保真度的执行路径和内存数据导致了不完整有偏差的分析结果。

现存动态分析依赖于以下三种技术：debugger调试器，dynamic binary instrumentation动态二进制插桩（通过注入插桩代码，来分析二进制应用程序在运行时的行为的方法），emulator（仿真器）

存在的困难包括：
（1）这些技术难以准确有效的收集所有已执行指令，因为 DBI 和模拟器可能会错误地识别和模拟指令，而调试器只能通过单步法single-step method（只根据前一点相关数据确定当前值）访问指令。因此，由于指令代码不完整，可能会错过本机代码的行为。

（2）这些技术可能被本地代码中的反分析方法轻松打败。

（3）这些底层技术引入了显著开销，导致了有偏颇的分析结果（可能被恶意代码分析到从而停止行为）

## 2、本文贡献

（1）利用ARM平台的硬件功能ETM（嵌入式跟踪微蜂窝），我们在真实设备（而不是仿真器）中收集执行的ARM 指令，无需 DBI 框架或基于软件的调试。通过ETM收集 ARM 指令的开销非常低（大约为零）。

（2）使用eBPF（扩展伯克利数据包过滤器），一个自安卓9.0以来推出的安卓系统的内核组件，可有效获得应用使用的内存数据。

（3）通过恢复运行时的函数调用和数据流，从收集的信息中识别本机代码的行为。

## 3、Embedded Trace Microcell

ARM平台的硬件功能，根据监控指令总线而几乎没有开销的追踪CPU执行的指令。当通过ETM追踪正在运行的app的执行指令时，ETM会产生包含恢复app运行轨迹信息的追踪元素trace elements，并将它们输出为ETM流。

在ETM输出流中我们主要分析address元素因为他存储了每个被追踪指令的地址，这将被用于回复app运行时的行为。

## 4、Extended Berkeley Packet Filter

一个轻量级的安全的用于执行eBPF程序的内核虚拟机。

一个eBPF程序可以通过kprobe结构或使用事件跟踪基础结构的内核跟踪点对一个内核指令挂钩（对特定的系统事件进行hook后，一旦发生已hook事件，对该事件进行hook的程序就会收到系统的通知，这时程序就能在第一时间对该事件做出响应）。一旦被挂钩的程序被执行，相关eBPF程序就会执行分析师指定的操作。

除了支持内核指令插入外，一个eBPF程序还可以利用用户空间的uprobe hook用户空间的程序，

# 三、NCScope

一个基于ETM+eBPF的目标程序数据收集模块（ARMv8）

> 记录指令路径，检索内存数据
>
> ETM被用于记录app执行的指令并调用eBPF程序去追踪app虚拟内存中的数据并将它们存储到内核中的一个内存空间
>
> 当本地代码执行结束，数据收集模块将输出指令追踪的ETM流以及由eBPF收集的内存数据，并将他们传送到分析模块完成各种任务。

一个实现了各种分析方法的分析模块

假设要分析的app无法获得根权限，应用程序既不能禁用eBPF，也不能禁用
一个内核模块，该模块检查用于配置 ETM去检测NCScope的存在的寄存器的值。

## 1、tracing instruction

默认情况下，ETM 会记录 CPU 执行的每个间接分支指令的目标地址。但从这样的ETM流中恢复app的行为比较困难，因为ETM流中会包含大量与待分析app无关的元素（将记录CPU执行的所有间接分支指令的目标地址），且ETM流只包括所有已执行的间接分支指令的目标地址，但实际上直接分支的目标地址也是需要的，因为他们可能会带来调用

**为了解决这些问题，NCScope 启用了ETM的上下文 ID 跟踪和分支广播跟踪。**

NCScope将DSTREAM这个off-chip设备作为缓冲区存储ETM流

### （1）context id tracing

上下文id追踪使得ETM只追踪被分析进程所执行的指令

> ***<u>it sets the CID field of TRCCONFIGR to 0x1, assigns the target app’s PID to the TRCCIDCVR0, and adjusts the COMP0 field of TRCCIDCCTLR0 to 0x1.</u>***

### （2）branch broadcast tracing

记录直接分支的目标地址

> <u>***setting the BB field of TRCCONFIGR to 0x1.***</u>
>
> <u>***assigns 0x0 and 0x7fffffffff to the ADDRESS field of TRCACVR0/1, and sets the RANGE field of TRCBBCTLR to 0x1.***</u>

## 2、collecting  memory data

利用eBPF在运行时收集app的内存数据，尤其是应用调用的系统函数的参数值。

### （1）retrieving memory data检索内存数据

第一步：为了获取数据首先获取内存中存储数据的基地址

> 利用一系列内核提供的宏，PT_REGS_PARM*,，去获得代表内存数据基地址的参数值

第二步：从第一步获取的基地址中获取数据

> 将基地址发送到由bcc提供的接口，bpf_probe_read，从而指导eBPF从基地址开始读取字节

### （2）storing memory data存储内存数据

参数值被存储在内核空间的虚拟内存中。一下提出两个问题:

通常系统函数被定义在共享库中，他们会被不同的app调用，因此检索到的内存数据有可能来源于其他app而不是正在被分析的app。因此要记录eBPF检测到的内存数据的**源（例如PID**），具体实现利用bpf_get_current_pid_tgid，有bcc提供的接口记录PID，然后将PID和内存数据一起记录。

由于内存数据的调用有顺序，并且这个顺序对于识别特定行为很有帮助，因此在记录识别到的内存数据时还要记录他们的时间戳并将它们按照**时间戳**排序。具体实现是利用bcc接口e bpf_ktime_get_ns 获取时间。

## 3、analysis module

要弥补原始数据（ETM流和内存数据）和高级语义数据（函数调用和数据流）之间的语义鸿沟。

### （1）recovering run-time function calls

提出一种新的解决ETM流的方法

首先，构造从每个指令地址到相应系统函数的映射，从而从跟踪指令流中确定被app调用的系统函数。

> 分析app的内存映射以及系统库和框架 OAT 文件的解汇编信息
>
> 具体来说，为每个可执行的内存区域找到他们的起始位置Vm，从而计算每个指令映射到虚拟内存中的地址；利用objdump和oatdump指令对系统库和框架OAT文件进行解汇编，从而识别出每条指令的文件偏移量Fi，将Vm+Fi+Omega（对于系统库，omega=系统库的文件偏移量-虚拟内存偏移量，对于OAT文件，omega=0-文件偏移量）得到每个地址为Vi的指令映射到虚拟内存中的地址值。

随后，根据构造好的映射，由存储在ETM流中 的地址元素address element找到app调用的系统函数.

具体操作：从 ETM 流中记录的每个地址元素获取跟踪指令的虚拟地址。由于地址元素使用最右边的位记录跟踪指令所处的指令集，NCScope 解析剩余的位获取指令的虚拟地址。紧接着，查询建立的指令-方程映射图来检查记录的指令地址是否与一个系统方程有关。

### （2）detecting self-protection module

定义了十种发现程序自我保护规则的方法，分为根检测和篡改检测tampering两种。

根检测：由于攻击者控制运行在根设备上的app，安全敏感型app会运用以下RTD方法避免在跟设备上运行。

（给出了七条检测原则和实现方法）

篡改检测：由于重新包装对于程序生态系统有很大的威胁，因此应用程序通常采用一下TPD方法保护自己免受篡改。

（给出了三条检测原则和实现方法）

### （3）detecting anti-analysis mechanisms

通过查询代码段和技术细节，总计了十二条反分析规则并分为五类

debugger detection：应用通常用以下三种DBD机制检测是否存在调试器从而避免被分析。

emulator detection：应用通常用以下三种EMD机制检测是否存在模拟器从而避免在模拟器环境下被分析。

DBI framework detection：应用通常用以下两种DFD机制检测DBI架构的存在

timing check：动态分析工具会增加程序执行时间，因此利用时间检测是否存在动态分析工具

dynamic code loading：为了躲避静态分析，应用程序会选择在运行时加载字节码或本机代码。列出三种动态加载的方法

### （4）diagnosing memory corruption bugs

根据运行时的执行轨迹ETM stream，NCScope使用离线符号执行来检测app的运行时数据流。通过检测运行时的数据流，NCScope可以诊断两种类型的内存泄露：
CWE-416 use after free:释放内存后引用内存可能导致程序崩溃、使用意外值或执行代码。

CWE-415 double-free：同一内存地址上调用 free（） 两次，可能导致修改意外的内存位置。

离线符号执行：考虑初始程序状态和运行时记录的执行轨迹，离线符号分析可以通过追踪执行轨迹中每条指令对应的数据值来恢复运行时的数据流。对于无法从初始状态分析的数据，他们将在执行轨迹中被符号化并传播。NCScope在执行本地代码前利用eBPF检测程序的初始状态。

use after free and double-free detection：在离线符号执行期间，NCScope检测所有内存分配和释放的调用，并分别将分配和释放的缓冲区记录在分配列表和释放列表上。

检测use after free：对于执行流中的所有指令现在分配列表进行地址检测，找到后再在释放列表进行地址检测，如果在释放列表中检测到了，则出现错误。

检测 double free：对于每个进行内存释放的调用，释放缓冲区的地址要先在释放列表上搜索一边，如果找到了，则出现错误。

### （5）extend NCScope

增加新的自我保护规则和反分析规则

诊断新的内存泄露bug：当进行离线符号执行时介绍新的检测规则

增加新功能：自定义eBPF程序指导eBPF检测需要的内存数据

# 四、评价

ETM检测：ds-5

评价eBPF功能的接口：adeb

进行离线符号执行：ARCUS

## 1、开销overhead

使用ETM时几乎没有性能开销，开启eBPF记录时会引入1.175x的开销

## 2、金融安卓app的原生代码中自我保护行为有多普遍

26.8%，且为精确诊断，没有假阴性和假阳性

## 3、安卓恶意软件原生代码中反分析机制有多普遍

78.3%,且为精确诊断，没有假阴性和假阳性

## 4、：NCScope可以协助诊断app原生代码中的内存损坏错误吗

通过在本机代码中标识“释放后使用”和“双重释放”,NCScope可以帮助诊断内存损坏，且没有假阴性和假阳性

## 5、NCScope可以协助分析app原生代码的性能吗

例子：分析得到当往一个文件中书写大量数据时，fwrite函数的用时比write少，性能更好。

且根据运行时的数据，可以分析出性能差异的根本性原因。

NCScope可以通过收集几乎没有噪音的准确数据来帮助实现对本机代码的性能分析。

# 五、不足/有效性威胁

1、由于动态分析的内在问题，NCScope可能不会触发正在分析的应用程序的所有指令，因此它可能会错过尚未执行的行为。

解决方法：使用自动应用检测工具驱动应用的执行；自定义目标执行工具来驱动app执行本地函数native function；未来扩大数据集

2、错过未定义的自我保护规则和反分析规则

解决方法：进一步补充规则

3、应用程序可能会通过侧通道检测 NCScope 以逃避分析。

解决方法：未来认真改进代码
