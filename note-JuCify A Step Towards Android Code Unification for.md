# JuCify: A Step Towards Android Code Unification for Enhanced Static Analysis

## 一、摘要

**模型目的**：在安卓应用程序中建立所有代码的统一模型。

**模型原理**：提取并合并本地代码和字节码的调用图，使最终模型易于被通用的Android分析框架使用。静态分析模型。

**JuCify建立在Soot内部中间表示之上，通过Jimple中间表示法支持JuCify统一模型。（Jimple广泛应用于SOOT框架中）**

<u>**启发式地用Jimple语句填充特定的本机函数。**</u>

**实验证明**：

（1）在没有统一模型的情况下，无论是良性还是恶意软件，从本地代码中调用的大量Java方法在应用程序的<u>调用图</u>中是“不可用unreachable”的。

（2）让静态分析器揭示恶意软件依赖原生代码来隐藏Android框架中对支付<u>库代码或其他敏感代码</u>的调用的情况。

（3）使最先进的工具能够在检测通过本机代码进行的<u>数据泄漏</u>时实现更好的精度和召回率。

（4）可以发现通过本地代码传递的<u>敏感数据泄漏</u>。

## 二、简介

**目的**：建立统一的安卓代码模型，打破字节编-本机代码边界。

**原理**：（1）依赖于符号执行来检索Dex字节码和本机之间的调用（Dex bytecode——native world）

​            （2）预先计算本机调用图（native call graph）

​            （3）合并Dex字节码和本机调用图

（4）利用代码工具（code instrumentation）定义的启发式Jimple声明（statement）填充新生成的函数

**实验结果**：（1）在数据流跟踪任务中，JuCify可以显著提高最先进的FlowDroid的效果，在一个新的旨在追踪字节码和原生代码间的数据流的基准数据集上，精度从0%提高到82%；召回率从0%到100%；

​                   （2）在一组真实的安卓应用程序上对JuCify进行了评估，表明它可以增强现有的分析器，使它们能够揭示以前无法检测到的通过原生代码实现的敏感数据泄漏问题。

## 三、背景知识

**Java**和**Kotlin**是支持安卓应用程序开发的两种主流编程语言。他们的程序被编译成**Dex字节码**，并包含在应用程序包中（以Dex文件的形式）。

### 1、JNI

JNI是FFI（foreign function interface）

java调用本机代码——使用关键字定义了一个本机方法相关的Java方法，称为Java本机方法。然后，注册其对应的本机函数，建立它们之间的映射。

本机代码调用java——Java对象的字段和方法也可以从本机代码中访问，并且可以使用特定的JNI接口函数进行调用。

本文提出的JuCify方法在**apk水平**上是有效的。因此，**调用位于字节码和编译的本机代码之间**。

## 四、JuCify模型

**目标**是将其Dex字节码和原生代码统一为一个统一的模型，并以Jimple表示（即流行的Soot框架的中间表示）实例化这个模型。

### 1、调用图作为统一的初步模型(Unified Preliminary Model)

调用图的顶点是**函数**。

**总体框架：**

首先，一个名为NATIVEDISCLOSER的子模块**构造本机调用图**并**提取字节码和本机代码之间的相互调用**

然后，在与字节码调用图合并之前，对**本地调用图进行修剪并准备与soot兼容**。

最终，由于与字节码-本机方法调用相关的信息，这两个调用图都是统一的（**合并**）。

**（1）本机调用图构造**

二进制分析框架**Angr** 被封装在NATIVEDISCLOSE子模块中。

**（2）字节码-本机代码调用提取**

❶检索字节码方法信息；

> 提取字节码方法的信息，例如方法的类，方法签名。
>
> 旨在完成对静态注册函数执行方法调用提取任务所需的签名信息。
>
> **AndroGuard**

❷提取输入方法entry method调用（字节码到本机）；

> 需要**匹配一个“Java本机方法”**(entry method)和一个entry function（即对应的本机函数）。
>
> 通过**符号执行**处理动态注册（JNI_onload）和静态注册（固定命名）
>
> 将apk的库（即.so）文件和上一步中的方法信息作为输入。它首先扫描每个二进制文件的符号表，以搜索(1)静态注册的本地函数和(2)动态注册函数的JNI_OnLoad函数。然后，如果存在JNI_OnLoad，则象征性地执行该函数，以进一步检测动态注册的本机函数。
>
> **符号执行依赖于Angr**

❸跟踪本机函数调用native function call并提取退出方法exit method调用。

> 从本地代码中**寻找一个字节码方法的调用**，称**exit method**为这个字节码方法。
>
> 退出原理：通过以链式的方式调用某些JNI接口函数来调用的退出方法。
>
> 具体实现：执行上一步所有得到的entry function从而得到exit method调用，并建立**entry function和exit function之间的关系映射**。
>
> **跟踪机制**：由于exit function可以在本机函数链中被深调用，但符号执行并不知道本机函数之间的边界。因此，我们在搜索exit function时实现了一个跟踪机制tracking mechanism。
>
> 从本机调用图中获得的每个本机函数的起始地址来维护一个本机函数的堆栈，并在到达一个新函数的起始地址时将其推入堆栈。从堆栈中弹出一个函数是由本机函数的返回地址的到来触发的，它可以在输入本机函数期间从基于架构规范（例如，链接寄存器LR为ARM）的某个寄存器或内存位置获得。这允许我们知道退出方法调用从哪个本机函数中发生。

**（3）调用图组件生成**

❶原生CG剪枝。

> 只保留相关的调用图部分。只保留从入口函数开始的子图（包括所有的后继节点），因为其余的部分将无法从字节码到达。

❷字节码CG构造。

> **FlowDroid**

**（4）字节码和本机调用图统一**

❶本地CG转换.

> 本地调用图需要一个转换步骤，以适应SOOT的技术约束。
>
> 一旦加载，两个调用图的节点集和边集就会被合并，但是这些调用图还没有连接在一起。

❷使用bytecode-to-native边来完善CG。

> 根据之前获取的entry method，entry method和他们对应的entry function之间的边被加入CG中

❸使用native-to-bytecode边来完善CG。

> 根据之前获取的exit method，exit method和他们对应的exit function之间的边被加入CG中
>
> 此步骤允许发现以前无法到达的字节码调用图节点。

### 2、从CG到Jimple统一模型

对于静态分析而言仍然缺少足够的信息，例如数据流分析。

FlowDroid为每个字节码方法bytecode metho提供CFG，其中的方法行为method behavior用Jimple语句表示。

**JuCify也将在特定的本机函数中添加Jimple语句。**

**实现此步后，对于一个给定的APK，我们得到了具有字节码和本机代码统一的APK的Jimple表示。**

**（1）本机函数生成**

> JuCify依赖于DummyBinaryClass，他的目的是**在SOOT representation中合并任何新导入的本机函数**。
>
> 对于nativeCG中的**每个native function**，JuCify会以适当的签名signature在**DummyBinaryClass中生成一个新方法**。

**（2）字节码方法语句检测**

>  JuCify生成bytecode-to-native CG边，他还必须在语句级别用**对新生成的本机函数的调用**来替换**对本机方法的初始调用**
>
> JuCify负责处理返回值和参数，以免欺骗任何基于新构建模型的分析

**（3）本机函数语句生成**

> 本机代码和Jimple代码之间不存在双射，字节码和本机代码操作无法直接翻译不同概念（例如指针）。因此，我们必须基于我们处理得到的信息进行启发式从而重建本地函数行为native function behavior。

## 五、实验

### 1、现实良性和恶意软件中使用原生代码的比例？

依靠AndroZoo存储库来构建一个2641194个良性应用程序的数据集（ no Antivirus in VirusTotal has flagged it）和一个174342个恶意应用程序的数据集（at least 10 Antivirus engines in VirusTotal have flagged it)），这两个数据集都包含了从2015年到2020年，我们从AndroZoo中收集到的所有应用程序。

检查它的APK文件中是否至少包含一个.so文件，检查每个应用程序是否有Java本机方法。

**本机调用在恶意软件中要常见得多（70%对43%）**

### 2、我们的字节码本机调用提取与SOTA相比效果如何？

开发并发布了**16个基准测试的应用程序**。所有这些应用程序都是可执行的安卓应用程序，并已在安卓8.1.0版本的Nexus 5手机上进行了测试。我们设计这些应用程序来涵盖不同的情况，如动态/静态注册、本机函数中的链接调用、通过结构和类传递参数、通过数组和函数返回访问字符串、字符串混淆等。

与NATIVE-SCANNER相比，JuCify提取退出调用具有更好的精度和召回率。此外，它还可以提供额外的信息，包括entry invocation和exit invocation。

### 3、JuCify是否可以提升现有的静态数据流分析器？

确定了4个案例，构建了11个基准应用程序，我们的基准应用程序建立在我们确定的四个案例上，以评估JuCify通过原生代码检测数据泄漏的能力。

Jucify对于提高flowdroroid等最先进的静态分析程序考虑原生代码至关重要。在我们构建的基准测试中，FlowDroid没有发现任何泄漏，它现在能够精确地识别大量样本中的泄漏（f1分数为90%）。

### 4、JuCify可以在多大程度上增强应用程序的调用图，并揭示以前无法访问的Java方法？

1）1000个良性应用程序；2) 1000个恶意软件。

请注意，我们只选择了至少包含一个.so文件的应用程序。该结果报告了有关JuCify成功更改调用图的应用程序。

JuCify可以帮助您发现应用程序行为中的新路径。它在良性和恶意软件应用程序中**增加了约5-6%的新节点的调用图**。总的来说，应用程序往往使用**更多的字节码到本机的调用**，而不是本机到字节码的调用。然而，**恶意软件似乎使用来自本机的字节码调用来执行可疑的活动**。

### 5、JuCify能否揭示在现实世界的应用程序中通过原生代码传递的以前无法获取的数据泄露？

从Androzoo中随机选择了1800个恶意应用程序（VirusTotal score> 20）。此外，为了检测数据泄漏，我们使用了FlowDroid提供的默认源source和接收器sink。对于这1800个应用程序中的每一个，我们都设置了一个1小时的超时时间（符号执行为30 min，FlowDroid执行30 min）。

进行两个具体案例分析，对这两个安卓应用程序都进行了手动检查，以确认FlowDroid检测到的泄漏的存在。

JuCify对于突出显示以前看不到的本地代码中的数据流非常有效。事实上，它增强的调用图使静态分析器能够揭示现实世界的安卓应用程序中的敏感数据泄露。

## 六、限制

（1）依赖于现有的工具来提取本机调用图和字节码和本机代码之间的相互调用，因此，这些工具的局限性被延续到了JuCify上。

这些限制包括符号执行的指数分析时间、查找本机函数边界的限制、由于反射调用、多线程和动态加载而导致的FlowDroid应用程序建模的不可靠性。

（2）依赖符号执行，符号执行不可伸缩。

（3）没有高精度地重建本机功能的行为。JuCify不能使用包含函数完整行为的Jimple语句生成本机函数的控制流图。

